package{	import FlasCCTest.lookupeffect.*;	import flash.display.*;	import flash.events.*;	import flash.geom.*;	import flash.utils.*;	import mx.core.*;		/**	 * @author	 * Bruce / http://bruce-lab.blogspot.com/	 * Ported to FlasCC from the Alchemy example by	 * Ralph Hauwert / http://unitzeroone.com/blog/2009/04/06/more-play-with-alchemy-lookup-table-effects/	 */	[SWF(width="512",height="512",backgroundColor="#000000")]		public class Main extends Sprite	{		[Embed(source="/diffuse.jpg")]		public static var diffuseClass:Class;				private static const IMAGE_WIDTH:int = 512;		private static const IMAGE_HEIGHT:int = 512;				private var alcDiffuseBitmapPointer:uint;		private var alcDiffusePointer:uint;		private var screenDiffuseBitmapData:BitmapData;		private var screenDiffuseBitmap:Bitmap;		private var diffuseBitmapData:BitmapData;				public function Main():void		{			stage.frameRate = 60;			stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.fullScreenSourceRect = new Rectangle(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);			addEventListener(Event.ADDED_TO_STAGE, initCode);		}				protected function initCode(event:Event):void		{			CModule.startAsync(this);			initBitmaps();			initData();			initRendering();		}				private function initBitmaps():void		{			var diffuseBitmapAsset:BitmapAsset = new diffuseClass() as BitmapAsset;						/**			 * We prepare the bitmap once to take into account the lower-endianess of the alchemy code.			 */			diffuseBitmapData = diffuseBitmapAsset.bitmapData.clone();			diffuseBitmapData = new BitmapData(diffuseBitmapData.width, diffuseBitmapData.height, true, 0xFF000000);			diffuseBitmapData.copyChannel(diffuseBitmapAsset.bitmapData, diffuseBitmapData.rect, diffuseBitmapData.rect.topLeft, BitmapDataChannel.ALPHA, BitmapDataChannel.BLUE);			diffuseBitmapData.copyChannel(diffuseBitmapAsset.bitmapData, diffuseBitmapData.rect, diffuseBitmapData.rect.topLeft, BitmapDataChannel.RED, BitmapDataChannel.GREEN);			diffuseBitmapData.copyChannel(diffuseBitmapAsset.bitmapData, diffuseBitmapData.rect, diffuseBitmapData.rect.topLeft, BitmapDataChannel.GREEN, BitmapDataChannel.RED);			diffuseBitmapData.copyChannel(diffuseBitmapAsset.bitmapData, diffuseBitmapData.rect, diffuseBitmapData.rect.topLeft, BitmapDataChannel.BLUE, BitmapDataChannel.ALPHA);						screenDiffuseBitmapData = new BitmapData(IMAGE_WIDTH, IMAGE_HEIGHT, false, 0);			screenDiffuseBitmap = new Bitmap(screenDiffuseBitmapData);			addChild(screenDiffuseBitmap);		}				protected function initData():void		{			//FlasCC calculates the lookuptables.			setupLookupTables_AS3();			//Allocate the buffers in FlasCC.			alcDiffuseBitmapPointer = initializeScreenDiffuseBuffer_AS3(IMAGE_WIDTH, IMAGE_HEIGHT); //Setup a screenbuffer of size x,y;			//Copy the diffuse texture we'll use to FlasCC memory.			var ba:ByteArray = diffuseBitmapData.getPixels(diffuseBitmapData.rect);			alcDiffusePointer = initializeDiffuseBuffer_AS3(IMAGE_WIDTH, IMAGE_HEIGHT);			ba.position = 0;			CModule.writeBytes(alcDiffusePointer, ba.length, ba);		}				protected function initRendering():void		{			addEventListener(Event.ENTER_FRAME, enterFrame);		}				protected function enterFrame(event:Event):void		{			//run the effect.			rasterize_AS3();			//retrieve the screen buffer from FlasCC.			CModule.ram.position = alcDiffuseBitmapPointer; //alcDiffusePointer;// 			screenDiffuseBitmapData.setPixels(screenDiffuseBitmapData.rect, CModule.ram);		/*		   //alternative way to retrieve the screen buffer from FlasCC.		   var ba : ByteArray  = new ByteArray();		   ba.endian = Endian.LITTLE_ENDIAN;		   //ba.length = 512 * 512 * 4;		   CModule.readBytes(alcDiffuseBitmapPointer, 512 * 512 * 4, ba);		   ba.position = 0;		   screenDiffuseBitmapData.setPixels(screenDiffuseBitmapData.rect, ba);		 */		}	}}